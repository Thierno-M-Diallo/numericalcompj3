//I hardcoded the matrix/ a majority of things. need to add more user implementation in order to abide by the rules
//also eventually change to matlab format

#include <iostream>
#include <vector>
#include <cmath>

// Function to print the matrix
void printMatrix(const std::vector<std::vector<double>>& matrix) {
    for (const auto& row : matrix) {
        for (auto val : row) {
            std::cout << val << " ";
        }
        std::cout << std::endl;
    }
}

// The Gauss-Seidel iterative method function
std::vector<double> gaussSeidel(std::vector<std::vector<double>> matrix, double tolerance) {
    int n = matrix.size();
    std::vector<double> x(n, 0.0); // Starting approximation at zero
    std::vector<double> x_old(n, 0.0);
    bool continueIteration = true;

    while (continueIteration) {
        continueIteration = false;
        for (int i = 0; i < n; i++) {
            double sum = matrix[i][n]; // b[i]
            for (int j = 0; j < n; j++) {
                if (j != i) {
                    sum -= matrix[i][j] * x[j];
                }
            }
            sum /= matrix[i][i];
            if (std::abs(x[i] - sum) > tolerance) {
                continueIteration = true;
            }
            x_old[i] = x[i];
            x[i] = sum;
        }

        // Check for convergence
        for (int i = 0; i < n; i++) {
            if (std::abs(x[i] - x_old[i]) > tolerance) {
                continueIteration = true;
                break;
            }
        }
    }

    return x;
}

int main() {
    // Example matrix with the system of equations in the form Ax = b
    // The last column represents the vector b
    std::vector<std::vector<double>> matrix = {
        {4, 1, 1, 9},
        {1, 4, -1, 1},
        {1, -1, 3, 7}
    };

    double tolerance = 0.0001; // Stopping criterion
    std::vector<double> results = gaussSeidel(matrix, tolerance);

    std::cout << "The roots are:" << std::endl;
    for (auto root : results) {
        std::cout << root << std::endl;
    }

    return 0;
}

